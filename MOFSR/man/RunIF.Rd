% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RunIF.R
\name{RunIF}
\alias{RunIF}
\title{Run Intermediate Fusion (IF) for Multi-Modality Data Integration}
\usage{
RunIF(
  data,
  algorithm,
  N.clust,
  data.types = c("binomial", "gaussian", "gaussian", "gaussian", "gaussian", "gaussian"),
  BCC.max.iterations = 10,
  CIMLR.num.dimensions = NA,
  CIMLR.tuning.parameter = 10,
  CIMLR.cores.ratio = 1,
  CPCA.num.components = 2,
  CPCA.integration.algorithm = "globalScore",
  CPCA.nonzero.coeff.k = "all",
  CPCA.center.data = FALSE,
  CPCA.scale.data = FALSE,
  CPCA.normalization.option = "uniform",
  CPCA.max.iterations = 1000,
  CPCA.return.moa.object = TRUE,
  CPCA.show.verbose = FALSE,
  CPCA.svd.solver.method = "fast.svd",
  CPCA.nonzero.coeff.obs = "all",
  CPCA.weight.variables = NA,
  CPCA.weight.observations = NA,
  CPCA.unit.length.variables = FALSE,
  CPCA.unit.length.observations = FALSE,
  CPCA.retain.nonnegative = FALSE,
  CPCA.clustering.algorithm = "ward.D2",
  iClusterBayes.num.burnin = 20,
  iClusterBayes.num.draws = 10,
  iClusterBayes.prior.probabilities = rep(0.5, length(data)),
  iClusterBayes.proposal.sdev = 0.05,
  iClusterBayes.thinning.interval = 3,
  IntNMF.max.iterations = 5,
  IntNMF.stability.count = 20,
  IntNMF.num.initializations = 30,
  IntNMF.use.nndsvd = TRUE,
  IntNMF.random.seed = TRUE,
  IntNMF.weight = NULL,
  LRAcluster.cluster.algorithm = "ward.D2",
  MCIA.n.components = 10,
  MCIA.clustering.algorithm = "ward.D2",
  MCIA.scan.eigenvalues = FALSE,
  MCIA.use.nsc = TRUE,
  MCIA.use.svd = TRUE,
  PINSPlus.agreement.cutoff = 0.5,
  PINSPlus.num.cores = 10,
  PINSPlus.sampled.set.size = 2000,
  PINSPlus.knn.k = NULL,
  RGCCA.connection.matrix = 1 - diag(length(data)),
  RGCCA.num.components = rep(1, length(data)),
  RGCCA.scheme = "centroid",
  RGCCA.regularization = "optimal",
  RGCCA.scale = TRUE,
  RGCCA.initialization = "svd",
  RGCCA.bias = TRUE,
  RGCCA.tolerance = 1e-08,
  RGCCA.verbose = FALSE,
  RGCCA.clustering.algorithm = "ward.D2",
  SGCCA.connection.matrix = 1 - diag(length(data)),
  SGCCA.num.components.per.modality = rep(1, length(data)),
  SGCCA.integration.scheme = "centroid",
  SGCCA.sparsity.level = rep(0.5, length(data)),
  SGCCA.scale.data = FALSE,
  SGCCA.initialization.method = "svd",
  SGCCA.use.biased.variance = TRUE,
  SGCCA.convergence.tolerance = .Machine$double.eps,
  SGCCA.show.progress = FALSE,
  SGCCA.cluster.algorithm = "ward.D2",
  SNF.num.neighbors = 20,
  SNF.variance = 0.5,
  SNF.num.iterations = 20,
  ...
)
}
\arguments{
\item{data}{A list of matrices where each element represents a different modality (e.g., RNA, protein, methylation). Each matrix should have rows as features and columns as samples.}

\item{algorithm}{Character. The integration algorithm to use. Options include "cpca", "iclusterbayes", "intnmf", "lracluster", "mcia", "nemo", "pinsplus", "rgcca", "sgcca", "snf", "cimlr", "bcc".}

\item{N.clust}{Integer. Number of clusters to create from the hierarchical clustering of the integrated components (optional but recommended).}

\item{data.types}{Character vector. Specifies the type of data for each modality (e.g., "binomial", "gaussian"). Default is a mixture of "binomial" and "gaussian".}

\item{BCC.max.iterations}{Integer. Maximum number of iterations for the BCC algorithm. Default is 10.}

\item{CIMLR.num.dimensions}{Integer. Number of dimensions for CIMLR. Default is NA.}

\item{CIMLR.tuning.parameter}{Numeric. Tuning parameter for CIMLR. Default is 10.}

\item{CIMLR.cores.ratio}{Numeric. Ratio of cores to use for CIMLR. Default is 1.}

\item{CPCA.num.components}{Integer. Number of components for CPCA. Default is 2.}

\item{CPCA.integration.algorithm}{Character. Integration algorithm for CPCA. Default is "globalScore".}

\item{CPCA.nonzero.coeff.k}{Character or numeric. Nonzero coefficient for CPCA. Default is "all".}

\item{CPCA.center.data}{Logical. Whether to center the data for CPCA. Default is FALSE.}

\item{CPCA.scale.data}{Logical. Whether to scale the data for CPCA. Default is FALSE.}

\item{CPCA.normalization.option}{Character. Normalization option for CPCA. Default is "uniform".}

\item{CPCA.max.iterations}{Integer. Maximum number of iterations for CPCA. Default is 1000.}

\item{CPCA.return.moa.object}{Logical. Whether to return MOA object for CPCA. Default is TRUE.}

\item{CPCA.show.verbose}{Logical. Whether to show verbose output for CPCA. Default is FALSE.}

\item{CPCA.svd.solver.method}{Character. SVD solver method for CPCA. Default is "fast.svd".}

\item{CPCA.nonzero.coeff.obs}{Character or numeric. Nonzero coefficient for observations in CPCA. Default is "all".}

\item{CPCA.weight.variables}{Numeric. Weight for variables in CPCA. Default is NA.}

\item{CPCA.weight.observations}{Numeric. Weight for observations in CPCA. Default is NA.}

\item{CPCA.unit.length.variables}{Logical. Whether to set unit length for variables in CPCA. Default is FALSE.}

\item{CPCA.unit.length.observations}{Logical. Whether to set unit length for observations in CPCA. Default is FALSE.}

\item{CPCA.retain.nonnegative}{Logical. Whether to retain nonnegative values in CPCA. Default is FALSE.}

\item{CPCA.clustering.algorithm}{Character. Clustering algorithm for CPCA. Default is "ward.D2".}

\item{iClusterBayes.num.burnin}{Integer. Number of burn-in iterations for iClusterBayes. Default is 20.}

\item{iClusterBayes.num.draws}{Integer. Number of draws for iClusterBayes. Default is 10.}

\item{iClusterBayes.prior.probabilities}{Numeric vector. Prior probabilities for iClusterBayes. Default is rep(0.5, length(data)).}

\item{iClusterBayes.proposal.sdev}{Numeric. Proposal standard deviation for iClusterBayes. Default is 0.05.}

\item{iClusterBayes.thinning.interval}{Integer. Thinning interval for iClusterBayes. Default is 3.}

\item{IntNMF.max.iterations}{Integer. Maximum number of iterations for IntNMF. Default is 5.}

\item{IntNMF.stability.count}{Integer. Stability count for IntNMF. Default is 20.}

\item{IntNMF.num.initializations}{Integer. Number of initializations for IntNMF. Default is 30.}

\item{IntNMF.use.nndsvd}{Logical. Whether to use NNDSVD for IntNMF. Default is TRUE.}

\item{IntNMF.random.seed}{Logical. Whether to use a random seed for IntNMF. Default is TRUE.}

\item{IntNMF.weight}{Numeric. Weight for IntNMF. Default is NULL.}

\item{LRAcluster.cluster.algorithm}{Character. Clustering algorithm for LRAcluster. Default is "ward.D2".}

\item{MCIA.n.components}{Integer. Number of components for MCIA. Default is 10.}

\item{MCIA.clustering.algorithm}{Character. Clustering algorithm for MCIA. Default is "ward.D2".}

\item{MCIA.scan.eigenvalues}{Logical. Whether to scan eigenvalues for MCIA. Default is FALSE.}

\item{MCIA.use.nsc}{Logical. Whether to use NSC for MCIA. Default is TRUE.}

\item{MCIA.use.svd}{Logical. Whether to use SVD for MCIA. Default is TRUE.}

\item{PINSPlus.agreement.cutoff}{Numeric. Agreement cutoff for PINSPlus. Default is 0.5.}

\item{PINSPlus.num.cores}{Integer. Number of cores to use for PINSPlus. Default is 10.}

\item{PINSPlus.sampled.set.size}{Integer. Sampled set size for PINSPlus. Default is 2000.}

\item{PINSPlus.knn.k}{Integer. K for k-NN in PINSPlus. Default is NULL.}

\item{RGCCA.connection.matrix}{Matrix. Connection matrix specifying the relationships between blocks for RGCCA. Default is 1 - diag(length(data)).}

\item{RGCCA.num.components}{Integer vector. Number of components for each block in RGCCA. Default is rep(1, length(data)).}

\item{RGCCA.scheme}{Character. Scheme for RGCCA. Default is "centroid".}

\item{RGCCA.regularization}{Character or numeric vector. Regularization parameter for RGCCA. Default is "optimal".}

\item{RGCCA.scale}{Logical. Whether to scale data for RGCCA. Default is TRUE.}

\item{RGCCA.initialization}{Character. Initialization method for RGCCA. Default is "svd".}

\item{RGCCA.bias}{Logical. Whether to use a biased estimator for RGCCA. Default is TRUE.}

\item{RGCCA.tolerance}{Numeric. Convergence tolerance for RGCCA. Default is 1e-08.}

\item{RGCCA.verbose}{Logical. Whether to show progress messages for RGCCA. Default is FALSE.}

\item{RGCCA.clustering.algorithm}{Character. Clustering algorithm for RGCCA. Default is "ward.D2".}

\item{SGCCA.connection.matrix}{Matrix. Connection matrix specifying the relationships between blocks for SGCCA. Default is 1 - diag(length(data)).}

\item{SGCCA.num.components.per.modality}{Integer vector. Number of components per modality for SGCCA. Default is rep(1, length(data)).}

\item{SGCCA.integration.scheme}{Character. Integration scheme for SGCCA. Default is "centroid".}

\item{SGCCA.sparsity.level}{Numeric vector. Sparsity level for each block in SGCCA. Default is rep(0.5, length(data)).}

\item{SGCCA.scale.data}{Logical. Whether to scale data for SGCCA. Default is FALSE.}

\item{SGCCA.initialization.method}{Character. Initialization method for SGCCA. Default is "svd".}

\item{SGCCA.use.biased.variance}{Logical. Whether to use a biased estimator for SGCCA. Default is TRUE.}

\item{SGCCA.convergence.tolerance}{Numeric. Convergence tolerance for SGCCA. Default is .Machine$double.eps.}

\item{SGCCA.show.progress}{Logical. Whether to show progress messages for SGCCA. Default is FALSE.}

\item{SGCCA.cluster.algorithm}{Character. Clustering algorithm for SGCCA. Default is "ward.D2".}

\item{SNF.num.neighbors}{Integer. Number of neighbors for SNF. Default is 20.}

\item{SNF.variance}{Numeric. Variance for SNF. Default is 0.5.}

\item{SNF.num.iterations}{Integer. Number of iterations for SNF. Default is 20.}
}
\value{
A list containing the clustering results based on the selected algorithm.
}
\description{
This function runs intermediate fusion (IF) analysis using a specified multi-modality clustering algorithm. Users can choose from a variety of clustering algorithms and adjust their respective parameters to perform data integration on multiple modalities, such as RNA, protein, and methylation.
}
\details{
This function allows the user to integrate multiple data modalities using a variety of different algorithms. Each algorithm has its own parameters that can be adjusted to fit the data and the research question. The function returns clustering results for each sample based on the selected algorithm.
}
\examples{
# Example usage:
data1 <- matrix(rnorm(10000), nrow = 100, ncol = 100)
data2 <- matrix(rnorm(10000), nrow = 100, ncol = 100)
colnames(data1) <- colnames(data2) <- paste0("Sample", 1:100)
data_list <- list(data1, data2)

# Run integration clustering using CPCA
result <- RunIF(data = data_list, algorithm = "cpca", N.clust = 3)
}
\author{
Zaoqu Liu; Email: liuzaoqu@163.com
}
